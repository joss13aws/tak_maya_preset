//- 문자열(파일명/경로)처리도구들

	//지정한 폴더루트의 내용을 검색하여 *_def.xml파일이 존재하는 파이프라인 생성 폴더의 리스트를 돌려줌...
	// $type => 어셋이냐 프로젝트냐 샷이냐...기타등등
	//- b2GetFolderList
	global proc string[] b2GetFolderList(string $path)
    {
	string $path = `b2AddSlash $path`;
	string $contents[] = `getFileList -folder $path`;
	string $eachContent;
	string $folderList[];
	int $i = 0;
	for ($eachContent in $contents)
	{
		string $path1 = ($path + $eachContent + "/" + $eachContent);
		string $path2 = ($path + $eachContent + "/" + $eachContent + "_def.xml");
		if (`filetest -r $path2`)
		{
		    // 마야 버전을 확인합니다 (정훈)
		    if(CheckProjectMayaVersionProc($path2) == true)
		    {
				$folderList[$i] = $eachContent;
				$i += 1;
		    }
		}
	}
	return $folderList;

	}
	
    // xml 파일 마야버전을 현재 실행한 마야버전과 비교합니다 (정훈)
    // 버전일치 = return true, 불일치 = return false, 버전정보 없음 = return true
    global proc int CheckProjectMayaVersionProc(string $filePath)
    {
        string $userName = `getenv userName`;
        
        switch($userName)
        {
            case "gkoh":
            case "ysson":
            case "jeseong":
            case "wmpark":
                return true;
            default:
                break;
        }
        
        // this maya version
        int $version = `about -version`;
        
        // project maya version
        int $projectMayaVersion = false;
        
        string $datas[]; clear $datas;
        $FileID = `fopen $filePath "r"`;
        int $i = 0;
        string $next = `fgetline $FileID`;
        while(`size($next)` > 0)
        {
            $datas[$i] = $next;
            $next = `fgetline $FileID`;
            $i++;
        }
        fclose $FileID;
        
        for($i = 0; $i < `size($datas)`; $i++)
        {
            string $reSubString = `substitute "<" $datas[$i] "_"`;
            $reSubString = `substitute ">" $reSubString "_"`;
            $reSubString = `substitute "</" $reSubString "_"`;
            $reSubString = `substitute ">" $reSubString "_"`;
            
            string $tokenStrings[]; clear $tokenStrings;
            tokenize $reSubString "_" $tokenStrings;
            
            if($tokenStrings[1] == "mayaVersion")
            {
                $projectMayaVersion = int($tokenStrings[2]);
                break;
            }
        }
        
        if($projectMayaVersion == false)
        {
            return true;
        }
        if($projectMayaVersion == $version)
        {
            return true;
        }
        return false;
    }
	//-/


	//- b2AddSlash 패스 문자열이 슬래쉬로 끝나지 않는 경우 슬래쉬를 끝에 붙여줌.
	global proc string b2AddSlash(string $path) 
	{
		if (!endsWith($path, "/"))
		$path += "/";
		return $path;	
	}
	//-/


	//- b2GetDepth 전달받은 인수로 패스의 depth를 계산함.
	global proc int b2GetDepth(string $val1, string $val2, string $val3)
	{
		int $depth = 0;
		if (size($val1))
		{
			$depth++;
			if (size($val2))
			{
				$depth++;
				if (size($val3))
				{
					$depth++;
				}
			}
		}
		return $depth;
	}
	//-/


	//- b2GetDepth2 샷 작업을 위한 depth 추출
	global proc int b2GetDepth2(string $val1, string $val2, string $val3, string $val4)
	{
		int $depth = 0;
		if (size($val1))
		{
			$depth ++;
			if (size($val2))
			{
				$depth ++;
				if (size($val3))
				{
					$depth++;
					if (size($val4))
					{
						$depth ++;
					}
				}
			}
		}
		return $depth;
	}
	//-/


	//- b2GetFolderFromPath 전달 받은 패스로부터 폴더 이름을 반환
	global proc string b2GetFolderFromPath(string $path, int $offsetFromLast)
	{
		string $tokenizedPath[];
		int $depth = tokenize($path, "/", $tokenizedPath);
		if (($depth - 1 - $offsetFromLast) >= 0)
			return ($tokenizedPath[$depth - 1 - $offsetFromLast]);
		else
			return "";
	}
	//-/


	//- b2Pad 숫자에 패딩 추가
	global proc string b2Pad(string $num, int $padding)
	{
		string $prefix = "";
		string $numString = string($num);
		string $returnString;
		int $length = size($numString);
		int $i;
		for ($i = $length; $i<$padding; $i ++)
		{
			$prefix = $prefix + "0";
		}
		$returnString = $prefix + $numString;
		return $returnString;
	}
	//-/


	//- b2UnPad 숫자에서 패딩 제거
	 global proc int b2Unpad(string $number)
	 {
		int $return;
		if ($number == "")
		{
			$return = 0;
		}
		else
		{
			string $prefix = `match "^0*" $number`;
			int $padding = size($prefix);
			int $size = size($number);
			string $subString;
			$subString = endString($number,($size-$padding));
			int $return = $subString;
			return $return;
		}
	}
	//-/


	//- b2GetVersionFromFile 버전 추출
	// $tag - "v"인 경우 develop 버전 인식, "r"인 경우 릴리즈 인식, "b"인경우 둘 다 인식, "n"인 경우 무조건 세자리 숫자 인식
	global proc int[] b2GetVersionFromFile(string $file, string $tag)
	{
		string $versionString;
		string $mainVersion;
		string $subVersion;
		int $outVersion[];
		if ($tag == "v" || $tag == "r")
		{
			$versionString = `match "_[vr]{1}[0-9]{3}.[0-9]{3}" $file`;
			if ($versionString == "")
			{
				$versionString = `match "_[vr]{1}[0-9]{3}" $file`;
				if ($versionString == "")
				{
					$versionString = `match "/[vr]{1}[0-9]{3}" $file`;
					if ($versionString == "")
					{
						$versionString = `match "^[vr]{1}[0-9]{3}" $file`;
					}
				}
			}
			string $tokenizedString[];
				tokenize ($versionString, ".", $tokenizedString);

			if ($tokenizedString[0] == "")
			{
				$tokenizedString[0] = "000";
			}
			if ($tokenizedString[1] == "")
			{
				$tokenizedString[1] = "000";
			}					
			$mainVersion = `match "[0-9]{3}" $tokenizedString[0]`;

			$subVersion = $tokenizedString[1];
			$outVersion[0] = $mainVersion;
			$outVersion[1] = $subVersion;
		}
		else if ($tag == "n")
		{
			$versionString = `match "[0-9]{3}" $file`;
			$outVersion[0] = $versionString;
			$outVersion[1] = 0;
		}
		else
		{
			$versionString = `match "_[0-9]{3}" $file`;
			$versionString = `substituteAllString $versionString "_" ""`;
			$outVersion[0] = $versionString;
			$outVerison[1] = 0;
		}
		return $outVersion;
	}
	//-/


	//- b2GetCategory 주어진 아이템이 어셋인지 샷인지, 혹은 컴포넌트인지 구분해줌
	global proc string b2GetCategory( int $tab, string $val1, string $val2, string $val3)
	{
		string $category;
		if ($tab == 2)
		{
			if (size($val3))
				$category = "component";
			else if (size($val2))
				$category = "asset";
			else if (size($val1))
				$category = "assetType";
		}
		else if ($tab == 3)
		{
			if (size($val3))
				$category = "shotComponent";
			else if (size($val2))
				$category = "shot";
			else if (size($val1))
				$category = "sequence";
		}
		return $category;
	}
	//-/


	// b2GetFileName
	// 기능		- 어셋용 filename genrator, 전달받은 인수들로 풀패스를 구성하여 돌려줌.
	// 입력		-$tab => 현재작업=1/어셋=2/샷=3 , 
	//			 $val1,2,3 => 디렉토리 depth, 
	//			 $subVersion => 선행 작업 버전
	//			 $mode => 	folder, parentDir, childDir, developDir --> 디벨롭 폴더, develop --> 최종 디벨롭 파일, nextDevelop --> 신규 디벨롭 파일
	//						releaseDir -->릴리즈 폴더, release -->최종 릴리즈 파일, nextRelease --> 신규 릴리즈 파일, 
	//						infoDir --> 히스토리 및 기타 정포 xml파일 폴더 , infoFile --> 어셋 스펙 정의 파일, historyFile --> 어셋 작업 히스토리 로그 파일
	//						dPreviewDir --> 디벨롭 프리뷰 이미지 폴더, rPreviewDir --> 릴리즈 프리뷰 이미지 폴더
	// 작동절차	-
	// 출력		- 파일명 (full path)
	//-
	global proc string b2GetFileName( int $tab, string $val1, string $val2, string $val3, string $subVersion, string $mode, int $offset)
	{
		int $depth = `b2GetDepth $val1 $val2 $val3`;
		string $userName = `optionVar -q "userName"`;
		string $projRoot = `optionVar -q "projRoot"`;
			$projRoot = `b2AddSlash $projRoot`;
		string $projName = `optionVar -q "selectedProjName"`;
		string $fileName = "";
		string $astDir = `optionVar -q "assetDir"`;
		string $shtDir = `optionVar -q "shotDir"`;
		string $devDir = `optionVar -q "developDir"`;
		string $devVerTag = `optionVar -q "developVerTag"`;
		string $relDir = `optionVar -q "releaseDir"`;
		string $relVerTag = `optionVar -q "releaseVerTag"`;
		string $compoDir = `optionVar -q "component"`;
		string $infoDir = `optionVar -q "infoDir"`;
		string $previewDir = "preview";
		string $previewName = "preview.jpg";
		string $previewTag = "preview";
		string $infoFile = "info.xml";
		
		if ($mode == "parentDir")
		{
			if ($depth == 3)
				$fileName = `b2GetFileName $tab $val1 $val2 "" 0 "folder" 0`;
			else if ($depth == 2)
				$fileName = `b2GetFileName $tab $val1 "" "" 0 "folder" 0`;
			else if ($depth == 1)
				$fileName = `b2GetFileName $tab "" "" "" 0 "folder" 0`;
		}
		else
		{
			if ($tab == 2)
				$fileName += $projRoot + $projName + "/" + $astDir;
			else if ($tab == 3)
				$fileName += $projRoot + $projName + "/" + $shtDir;
			else
				return "";
			if (size($val1))
			{
				$fileName += "/" + $val1 + "/";
				if (size($val2))
				{
					$fileName += $val2 + "/";
					if (size($val3))
					{
						$fileName += $val3 + "/";
						if ($mode == "developDir")
						{
							$fileName += $devDir + "/";
						}
						else if ($mode == "releaseDir")
						{
							$fileName += $relDir + "/";
						}
						else if ($mode == "infoDir")
						{
							$fileName += $infoDir + "/";
						}
						else if ($mode == "infoFile")
						{
							$fileName += $infoDir + "/" + $infoFile;
						}
						else if ($mode == "develop")
						{
							string $devPath = $fileName + $devDir + "/";
							string $devDirContents[] = `getFileList -folder $devPath -filespec ( $devVerTag + "*")`;
							string $validFolders[];
							for ($eachContent in $devDirContents)
							{
								string $match = `match "v[0-9]{3}" $eachContent`;
								int $fileTest = `filetest -d ($devPath + $eachContent)`;
								if (size($match) && $fileTest)
								{
									$validFolders[size($validFolders)] = $eachContent;
								}
							}
							$validFolders = `sort($validFolders)`;
							int $developNum = size($validFolders);
							if ($developNum)
							{
								int $order = $developNum - 1 - $offset;
								if ($order >= 0)
								{
									string $versionPath = ($devPath + $validFolders[$order] + "/");
									string $devFile[] = `getFileList -folder $versionPath -filespec "*.ma"`;
									$fileName = ($versionPath + $devFile[0]);
								}
								else
									$fileName = "";
							}
							else
							{
								$fileName = "";
							}
						}
						else if ($mode == "nextDevelop")
						{
							string $devPath = $fileName + $devDir + "/";
							string $devDirContents[] = `getFileList -folder $devPath -filespec ( $devVerTag + "*")`;
							string $validFolders[];
							for ($eachContent in $devDirContents)
							{
								string $match = `match "v[0-9]{3}" $eachContent`;
								int $fileTest = `filetest -d ($devPath + $eachContent)`;
								if (size($match) && $fileTest)
								{
									$validFolders[size($validFolders)] = $eachContent;
								}
							}
							$validFolders = `sort($validFolders)`;
							int $developNum = `size($validFolders)`;
							int $latestDevelop = 0;
							if ($developNum)
							{
								int $version[] = b2GetVersionFromFile($validFolders[$developNum - 1], "v");
								$latestDevelop = $version[0];
							}
							string $outVersionString = b2Pad(($latestDevelop + 1), 3);
							$outVersionString = $devVerTag + $outVersionString;
							$fileName = ($devPath + $outVersionString + "/" + $val1 + "_" + $val2 + "_" + $val3 + "_" + $outVersionString + "_" + $userName + ".ma");
						}
						else if ($mode == "release")
						{
							string $relPath = $fileName + $relDir + "/";					
							string $releaseFolderContents[] = `getFileList -folder $relPath -filespec ( $relVerTag + "*")`;
							string $validFolders[];
							for ($eachContent in $releaseFolderContents)
							{
								string $match = `match "r[0-9]{3}" $eachContent`;
								int $fileTest = `filetest -d ($relPath + $eachContent)`;
								if (size($match) && $fileTest)
								{
									$validFolders[size($validFolders)] = $eachContent;
								}
							}
							$validFolders = `sort $validFolders`;
							int $releaseNum = size($validFolders);
							if ($releaseNum)
							{
								int $order = $releaseNum - 1 - $offset;
								if ($order >= 0)
								{
									string $versionPath = ($relPath + $validFolders[$order] + "/");
									string $relFile[] = `getFileList -folder $versionPath -filespec "*.ma"`;
									$fileName = $versionPath + $relFile[0];
								}
								else
									$fileName = "";
							}
							else
							{
								$fileName = "";
							}
						}
						else if ($mode == "nextRelease")
						{
							string $relPath = $fileName + $relDir + "/";
							string $releaseFolderContents[] = `getFileList -folder $relPath -filespec ($relVerTag + "*")`;
							string $validFolders[];
							for ($eachContent in $releaseFolderContents)
							{
								string $match = `match "r[0-9]{3}" $eachContent`;
								int $fileTest = `filetest -d ($relPath + $eachContent)`;
								if (size($match) && $fileTest)
								{
									$validFolders[size($validFolders)] = $eachContent;
								}
							}
							int $releaseNum = size($validFolders);
							int $latestRelease = 0;
							if ($releaseNum)
							{
								int $version[] = b2GetVersionFromFile($validFolders[$releaseNum - 1], "r");
								$latestRelease = $version[0];
							}
							string $outVersionString = b2Pad(($latestRelease + 1), 3);
							$outVersionString = ("r" + $outVersionString);
							$fileName = ($relPath + $outVersionString + "/" + $val1 + "_" + $val2 + "_" + $val3 + "_" + $outVersionString + ".ma");
						}
						else if ($mode == "historyFile")
						{
							string $compoName = b2GetFolderFromPath($fileName,0);
							string $parentName = b2GetFolderFromPath($fileName,1);
							string $grandParentName = b2GetFolderFromPath($fileName,2);
							$fileName = ($fileName + $infoDir + "/" + $val1 + "_" + $val2 + "_" + $val3 + "_History.xml");
						}
						else if ($mode !="folder")
						{
							$fileName = "";
							warning ("b2Pipeline (b2GetFileName) unrecognized file mode : " + $mode);
						}
					}

				}

			}
		}		
		return $fileName;
	}
	//-/


	// b2GetFileName2
	// 애니메이션 작업을 위한 파일네임 처리
	//mode가 release/nextRelease인 경우 디렉토리 패스를 반환. 그 외의 경우는 파일명까지 반환
	//-
	global proc string b2GetFileName2( string $val1, string $val2, string $val3, string $val4, string $devVer, string $mode, int $offset)
	{
		int $depth = `b2GetDepth2 $val1 $val2 $val3 $val4`;
		string $userName = `optionVar -q "userName"`;
		string $projRoot = `optionVar -q "projRoot"`;
			$projRoot = `b2AddSlash $projRoot`;
		string $projName = `optionVar -q "selectedProjName"`;
		string $fileName;
		string $shotDir = `optionVar -q "shotDir"`;
		string $developDir = `optionVar -q "developDir"`;
		string $developVerTag = `optionVar -q "developVerTag"`;
		string $releaseDir = `optionVar -q "releaseDir"`;
		string $releaseVerTag = `optionVar -q "releaseVerTag"`;
		string $infoDir = `optionVar -q "infoDir"`;
		string $previewDir = "preview";
		string $previewName = "preview.jpg";
		string $previewTag = "preview";
		string $infoFile = "info.xml";
		string $devVersionString = b2Pad($devVer, 3);
		string $mayaProj = ($val1 + "_" + $val2 + "_maya/");
		
		if ($mode == "parentDir")
		{
		//-상위 디렉토리 추출
			if ($depth == 4)
				$fileName = `b2GetFileName2 $val1 $val2 $val3 "" 0 "folder" 0`;
			else if ($depth == 3)
				$fileName = `b2GetFileName2 $val1 $val2 "" "" 0 "folder" 0`;
			else if ($depth == 2)
				$fileName = `b2GetFileName2 $val1 "" "" "" 0 "folder" 0`;
			else if ($depth == 1)
				$fileName = `b2GetFileName2 "" "" "" "" 0 "folder" 0`;
		//-/
		}
		else
		{
			$fileName += $projRoot + $projName + "/" + $shotDir;
			if (size($val1))
			{
				$fileName += "/" + $val1 + "/";
				if (size($val2))
				{
					if ($mode == "maya")
					{
						$fileName += $val2 + "/" + $mayaProj;
					}
					else
					{
						$fileName += $val2 + "/";
					}				
					if (size($val3))
					{
						$fileName += ($mayaProj + "scenes/" + $val3 + "/");
						if (size($val4))
						{
						//- 마야 DB 하위 파일명 생성 (마야 프로젝트 scenes 하위)
							$fileName += ($val4 + "/");
							if ($mode == "developDir")
							{
								$fileName += $developDir + "/";
							}
							else if ($mode == "releaseDir")
							{
								$fileName += $releaseDir + "/";
							}
							else if ($mode == "infoDir")
							{
								$fileName += $infoDir + "/";
							}
							// else if ($mode == "infoFile")
							// {
								// $fileName += $infoDir + "/" + $infoFile;
							// }
							else if ($mode == "historyFile")
							{
								$fileName += ($infoDir + "/" + $val1 + "_" + $val2 + "_" + $val3 + "_" + $val4 + "_History.xml");
							}
							else if ($mode == "develop")
							{
								string $devPath = $fileName + $developDir + "/";
								string $developFolderContents[] = `getFileList -folder ($devPath) -filespec ( "*" + $developVerTag + "*")`;
								$developFolderContents = `sort $developFolderContents`;
								string $validFolders[];
								for ($eachContent in $developFolderContents)
								{
									string $match = `match "^v[0-9]{3}" $eachContent`;
									int $fileTest = `filetest -d ($devPath + $eachContent)`;
									if (size($match) && $fileTest)
									{
										$validFolders[size($validFolders)] = $eachContent;
									}
								}
								$validFolders = `sort($validFolders)`;
								int $developNum = size($validFolders);
								if ($developNum)
								{
									int $order = $developNum - 1 - $offset;
									if ($order >= 0)
									{
										string $versionPath = ($devPath + $validFolders[$order] + "/");
										string $devFile[] = `getFileList -folder $versionPath -filespec "*.ma"`;
										if (!size($devFile) || size(`match "_cam" $devFile[0]`))
										{
											$devFile = `getFileList -folder $versionPath -filespec "*.mb"`;
										}
										$fileName = $versionPath + $devFile[0];
									}
								}
								else
									$fileName = "";
							}
							else if ($mode == "nextDevelop")
							{
								string $devPath = $fileName + $developDir + "/";
								string $developFolderContents[] = `getFileList -folder $devPath -filespec ($developVerTag + "*")`;
								string $validFolders[];
								for ($eachContent in $developFolderContents)
								{
									string $match = `match "v[0-9]{3}" $eachContent`;
									int $fileTest = `filetest -d ($devPath + $eachContent)`;
									if (size($match) && $fileTest)
									{
										$validFolders[size($validFolders)] = $eachContent;
									}
								}
								string $newVersionString;
								int $developNum = `size($validFolders)`;
								int $latestDevelop = 0;
								if ($developNum)
								{
									int $version[] = b2GetVersionFromFile($validFolders[$developNum - 1], "v");
									$latestDevelop = $version[0];
								}
								string $newVersionString = b2Pad(($latestDevelop + 1), 3);
								$newVersionString = $developVerTag + $newVersionString;
								$fileName = ($devPath + $newVersionString + "/" + $val1 + "_" + $val2 + "_" + $val3 + "_" + $val4 + "_" + $newVersionString + "_" + $userName + ".ma");	
							}
							else if ($mode == "release")
							{
								string $releaseDirList[] = `getFileList -folder ($fileName + $releaseDir + "/") -filespec ($releaseVerTag + "*")`;
								$releaseDirList = `sort $releaseDirList`;
								int $releaseDirCount = size($releaseDirList);
								if ($releaseDirCount)
								{
									int $order = $releaseDirCount - 1 - $offset;
									if ($order >= 0)
									{
										$fileName += ($releaseDir + "/" + $releaseDirList[$order] + "/");
									}
								}
								else
								{
									$fileName = "";
								}
							}
							else if ($mode == "nextRelease")
							{
								string $relPath = $fileName + $releaseDir + "/";
								string $releaseFolderContents[] = `getFileList -folder $relPath -filespec ($releaseVerTag + "*")`;
								string $validFolders[];
								for ($eachContent in $releaseFolderContents)
								{
									string $match = `match "r[0-9]{3}" $eachContent`;
									if (size($match))
									{
										$validFolders[size($validFolders)] = $eachContent;
									}
								}
								int $releaseNum = size($validFolders);
								int $latestRelease = 0;
								if ($releaseNum)
								{
									int $version[] = b2GetVersionFromFile($validFolders[$releaseNum - 1], "r");
									$latestRelease = $version[0];
								}
								string $newVersionString = b2Pad(($latestRelease + 1), 3);
								$newVersionString = ("r" + $newVersionString);
								$fileName = $relPath + $newVersionString;
							}
						//-/
						}
						else if ($mode !="folder")
						{
							warning ("b2Pipeline (b2GetFileName2) unrecognized file mode : " + $mode);
						}
					}				
				}				
			}				
		}
		return $fileName;
	}
	//-/


	// b2CheckValueFormat
	// 기능		- 입력받은 값이 용도에 맞는 형식인지 확인
	//-
	global proc int b2CheckValueFormat ( string $type, string $value, string $element )
	{
		/*
		Description:
			Parsing given value whether fit to the purpose.
		
		Parameters:
			$type: string, Data type of value.
			$value: string, User input value.
			$element: string, Check where user input on 'asset' or 'shot'. Asset name can't have dash(-) character.

		Returns:
			1 or 0: int
		*/

		string $validWords;
		switch( $type )
		{
			case "float":
				$validWords = "[0-9]*[.][0-9]*";
				break;
			case "string":
				if ($element == "asset")
				{
					$validWords = "[0-9a-zA-Z_]*";
				}
				else if ($element == "default")
				{
					$validWords = "[0-9a-zA-Z-]*";
				}
				break;
			case "int":
				$validWords = "[0-9]*";
				break;
		}
		string $matchResult = `match $validWords $value`;
		if( size($matchResult) == size($value) )
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}

	//-/

	
//-/


//- 씬 분석도구들

	//- b2GetCameraList 루트 네임스페이스에 속해있는 카메라 리스트를 반환
	global proc string[] b2GetCameraList()
	{
		string $camItemAll[] = `ls -type "camera"`;
		string $camInNamespace[];
		string $defaultCam[] = { "perspShape", "topShape", "sideShape", "frontShape" };
		string $camInRoot[];
		string $exportCam[];
		for ($cam in $camItemAll)
		{
			string $inNamespace = `match "[a-zA-Z0-9]*:" $cam`;
			if (size($inNamespace))
			{
				$camInNamespace[size($camInNamespace)] = $cam;
			}
		}
		$camInRoot = stringArrayRemove ($camInNamespace, $camItemAll);
		$exportCam = stringArrayRemove ($defaultCam, $camInRoot);
		for( $i=0; $i<size($exportCam); $i++ )
		{
			string $transform[] = `listRelatives -parent $exportCam[$i]`;
			$exportCam[$i] = $transform[0];
		}
		return $exportCam;
	}
	//-/

	
	// b2GetBGSetList
	// 기능		- 씬에 존재하는 set(배경)의 namespace 목록을 반환
	// 작동절차	- 모든 레퍼런스 파일을 검색하여 파일명이 `set_`로 시작하는 레퍼런스의 네임스페이스 목록을 작성하여 반환
	// 입력		- 없음
	//	출력	- 네임스페이스 목록(array)
	//- 
	global proc string[] b2GetBGSetList()
	{
		string $bgList[];
		string $rawRefLst[] = `ls -type "reference"`;
		string $refList[] = {};
		for ($ref in $rawRefLst)
		{
			if (catch(`referenceQuery -filename $ref`))
			{
				continue;
			}

			$refList[size($refList)] = $ref;
		}
		
		string $remItems[] = { "sharedReferenceNode" };
		$refList = stringArrayRemoveExact( $remItems, $refList );
		print "$refList[] =\n";
		print $refList;
		print "\n";	
		for( $eachRef in $refList )
		{
			string $matchWord = `match "sharedReferenceNode" $eachRef`;
			if( !size($matchWord) )
			{
				string $refFile = `referenceQuery -filename $eachRef`;
				$refFile = `basenameEx $refFile`;
				if( size(`match "^set_" $refFile`) || size(`match "^bg_" $refFile`) )
				{
					string $node[] = `referenceQuery -nodes $eachRef`;
					string $ns[] = `stringToStringArray $node[0] ":"`;
					$bgList[size($bgList)] = $ns[0];
				}
			}
		}
		return $bgList;
	}
	//-/
	
		
	// b2GetRefAstType
	// 기능		- 주어진 레퍼런스이름에서 어셋 타입을 반환
	//-
	global proc string b2GetRefAstType( string $refName )
	{
		string $matchWord = `match "sharedReferenceNode" $refName`;
		if( !size($matchWord) )
		{
			string $refFile = `referenceQuery -filename $refName`;
			$refFile = `basenameEx $refFile`;
			string $buffer[] = `stringToStringArray $refFile "_"`;
			return $buffer[0];
		}
	}
	//-/
	
	
	//- b2GetCachingAssetList
	global proc string[] b2GetCachingAssetList()
	{
		string $assetList[];
		string $cacheSetList[] = `ls -type "objectSet" "*:cache_set"`;
		for ($item in $cacheSetList)
		{
			string $buffer[] = stringToStringArray ($item, ":");
			$assetList[size($assetList)] = $buffer[0];
		}
		return $assetList;
	}
	//-/
	
	
	// b2GetAbcExportAstList
	//
	//-
	global proc string[] b2GetAbcExportAstList( string $keyword )
	{
		string $astLst[];
		string $rawRefLst[] = `ls -type "reference"`;
		string $refLst[] = {};
		for ($ref in $rawRefLst)
		{
			if (catch(`referenceQuery -filename $ref`))
			{
				continue;
			}

			$refLst[size($refLst)] = $ref;
		}

		string $remItems[] = { "sharedReferenceNode" };
		$refLst = stringArrayRemove( $remItems, $refLst );
		string $keywordSub;
		if( `startsWith $keyword "!"` )
		{
			$keywordSub = `substituteAllString $keyword "!" ""`;
		}
		for( $eachRef in $refLst )
		{
			string $matchWord = `match "sharedReferenceNode" $eachRef`;
			if( !size($matchWord) )
			{
				string $astType = `b2GetRefAstType $eachRef`;	
				int $length = size($eachRef);
				int $returnLength = $length - 2;
				string $astNs = `substring $eachRef 1 $returnLength`;
				if( size($keywordSub) )
				{				
					if( $keywordSub != $astType )
					{
						$astLst[size($astLst)] = $astNs;
					}
					else
						continue;
				}			
				else if( $keyword == $astType )
				{
					$astLst[size($astLst)] = $astNs;
				}
			}
		}
		return $astLst;
	}
	
	
	//-/
	
	
	// b2GetNonCachingAssetList
	//-
	global proc string[] b2GetNonCachingAssetList()
	{
		string $rawRefLst[] = `ls -type "reference"`;
		string $refList[] = {};
		for ($ref in $rawRefLst)
		{
			if (catch(`referenceQuery -filename $ref`))
			{
				continue;
			}

			$refList[size($refList)] = $ref;
		}

		string $remItems[] = { "sharedReferenceNode" };
		$refList = stringArrayRemoveExact( $remItems, $refList );
		string $nsList[];
		for( $eachRef in $refList )
		{
			string $nodes[] = `referenceQuery -nodes $eachRef`;
			string $ns[] = `stringToStringArray $nodes[0] ":"`;
			$nsList[size($nsList)] = $ns[0];
		}
		string $cachingAssetNs[] = `b2GetCachingAssetList`;
		string $bgAssetNs[] = `b2GetBGSetList`;
		string $diff[] = stringArrayRemove( $cachingAssetNs, $nsList );
		$diff = stringArrayRemove( $bgAssetNs, $diff );
		
		return $diff;
	}
	//-/

	
	
	//- 선택한 버전의 어셋 LOD존재 여부 체크
	global proc string[] b2CheckLOD()
	{
		string $lodList[];
		
		//ui에서 선택한 버전과 마지막 버전을 비교해 파일을 찾기 위한 offset 값 추출
		string $selectedItem[] = `b2GetCurrentlySelectedItem 2 3`;
		string $selectedVersionString = `textField -q -text selectedAssetVersionField`;
		string $latestVersionString;	
		int $selectedVersion = `match "[0-9]{3}" $selectedVersionString`;
		string $type = `match "[a-z]" $selectedVersionString`;
		if ($type == "v")
		{
			$type = "develop";
			$latestVersionString = `textField -q -text latestDevelopDisp`;
		}
		else
		{
			$type = "release";
			$latestVersionString = `textField -q -text latestReleaseDisp`;
		}
		int $latestVersion = `match "[0-9]{3}" $latestVersionString`;
		int $offset = $latestVersion - $selectedVersion;
		
		//파일명에서 lod를 체크해 lod버전 목록을 반환
		string $fileName = `b2GetFileName 2 $selectedItem[0] $selectedItem[1] $selectedItem[2] 0 $type $offset`;
		string $baseName = `basenameEx $fileName`;
		string $dirPath = `dirname $fileName`;
		string $shareName = `match "[a-zA-Z_0-9]*.[0-9]*" $baseName`;
		string $fileList[] = `getFileList -folder ($dirPath + "/") -filespec "*.ma"`;
		if (size($fileList))
		{
			for ($item in $fileList)
			{
				string $lodName = `match "_lod[0-9]{2}_" $item`;
				if( size($lodName) )
				{
					$lodName = `substituteAllString  $lodName "_" ""`;
				}
				$lodList[size($lodList)] = $lodName;
			}
		}
		return $lodList;
	}
	//-/

	
	// b2CheckRootNode
	// 기능		- 씬의 최상위에 root라는 이름의 노드가 존재하는지 체크.
	// 출력		- :	0 씬이 비어있음
	//				1 root 노드가 존재함
	//				2 최상위 그룹의 이름이 root가 아님
	//				3 최상위에 여러개의 노드가 있음
	//-
	global proc int b2CheckRootNode( string $type )
	{
		string $topNodes[] = `ls -assemblies`;
		string $defaultTopNodes[] = { "persp", "top", "front", "side" };
		string $checkRootGrp[] = stringArrayRemove ( $defaultTopNodes, $topNodes );
		string $warningString;
		if (size($checkRootGrp) == 1)
		{
			if ($checkRootGrp[0] == "|root")
			{
				$warningString = "";
			}
			else if ($checkRootGrp[0] == "root")
			{
				$warningString = "";
			}
			else
			{
				$warningString = "어셋의 최상위 노드 이름이 `root`가 아닙니다";
			}
		}
		else if (size($checkRootGrp) == 0)
		{
			$warningString = "현재 씬이 비어있습니다";
		}
		else if( $type == "rel" && size($checkRootGrp) > 1 )
		{
			// $warningString = "씬의 최상위에 복수의 노드가 존재합니다.";
			$warningString = "";
		}
		if ($warningString != "")
		{
			confirmDialog -title "Warning!" -message $warningString;
			return 0;
		}
		else
		{
			return 1;
		}

	}
	//-/


	//- b2FurAttrMapList furDescription 노드에서 맵이 지정된 어트리뷰트의 리스트를 반환
	global proc string[] b2FurAttrMapList()
	{
		if( !`pluginInfo -query -loaded -name "Fur"` )
		{
			loadPlugin "Fur";
		}
		string $list[] = `ls -type "FurDescription"`;
		string $returnNodes[];
		for ($node in $list)
		{
			string $multiAttrList[] = `listAttr -multi $node`;
			for ($attrEntry in $multiAttrList)
			{
				string $matchResult = `match "[a-zA-Z]*Map\\[[0-9]\\]" $attrEntry`;
				if (`size($matchResult)`)
				{
					string $path = `getAttr ($node + "." + $attrEntry)`;
					if (`size($path)`)
					{
						$returnNodes[`size($returnNodes)`] = $node + "." + $attrEntry;
					}
				}
			}
		}
		return $returnNodes;
	}
	//-/


	//- b2CheckFurAttrMap furDescription 노드의 파일 존재 유무만 체크
	global proc b2CheckFurAttrMap()
	{
		string $furDescNodes[] = `b2FurAttrMapList`;
		string $badNode[];
		string $goodNode[];
		for ($entry in $furDescNodes)
		{
			string $furNodeName[] = stringToStringArray ($entry, ".");
			print "====================================================================================================================\n";
			print "$furNodeName[]\n";
			print $furNodeName;
			print "\n";
			string $attrMapPath = `getAttr $entry`;
			print ("$attrMapPath = " + $attrMapPath + "\n");
			print "====================================================================================================================\n\n";
			if (!`filetest -f $attrMapPath`)
			{
				$badNode[size($badNode)] = $furNodeName[0];
			}
			else
			{
				$goodNode[size($goodNode)] = $furNodeName[0];
			}
		}
	}
	//-/


	//- b2TestAllCacheNodes씬 안의 모든 캐쉬파일 노드의 리스트를 뽑아 경로 검색 후 빈 노드/ 파일 없는 노드와 같은 경로를 참조하는 노드의 그룹을 반환
	global proc string[] b2TestAllCacheNodes()
	{
		print "b2TestAllCacheNodes...____________________________________________starting up procedure\n";
		string $selectCacheNodesCommand = "ls -type cacheFile";
		string $cacheNodes[] = `eval($selectCacheNodesCommand)`;
		string $cacheNodesSize = size($cacheNodes);
		string $pathGroup[];
		if ($cacheNodesSize)
		{
			$pathGroup[0] = "missingPath";
			$pathGroup[1] = "emptyCacheNode";
		}
		for ($item in $cacheNodes)
		{
			int $pathGroupSize = size($pathGroup);
			string $baseDir = `getAttr ($item + ".cachePath")`;
			$baseDir = `toNativePath($baseDir)`;
			string $cacheName = `getAttr ($item + ".cacheName")`;
			string $existingPath;
			string $tmp;
	//		print ("evaluating " + $item + "\n");
			if (size($baseDir))
			{
				for ($j = 2; $j < $pathGroupSize; $j ++)
				{
					string $buffer[];
						tokenize $pathGroup[$j] "*" $buffer;
					$existingPath = $buffer[0];
					string $path1 = $baseDir;
					string $path2 = $existingPath;
					if ($path1 == $path2)
					{
						$tmp = $pathGroup[$j];
						$tmp += "*" + $item;
						$pathGroup[$j] = $tmp;
						break;
					}
				}
				if ($j >= $pathGroupSize)
				{
					$pathGroup[$pathGroupSize] = $baseDir + "*" + $item;
				}
			}
			else if ($cacheName != "")
			{
				$tmp = $pathGroup[0];
				$tmp += "*" + $item;
				$pathGroup[0] = $tmp;
			}
			else
			{
				string $tmp = $pathGroup[1];
				$tmp += "*" + $item;
				$pathGroup[1] = $tmp;
			}
		}
		print "b2TestAllCacheNodes...____________________________________________procedure is finished\n";
		return $pathGroup;
	}
	//-/


	//- b2CheckCacheExistence모든 캐쉬파일 노드의 경로를 검색해 실제로 파일이 존재하는지 확인 후 문제가 있는 노드 리스트를 반환
	global proc string[] b2CheckCacheExistence()
	{
		string $pathList[] = `b2TestAllCacheNodes`;
	//	print "check0_$pathList[]\n";
	//	print $pathList;
		int $pathListSize = size($pathList);
		string $cacheNode;
		string $cacheDir;
		string $cacheName;
		string $xmlFilePath;
		string $mcFilePath;
		string $badNode[];
		string $goodNode[];
		string $fileName;
		if ($pathList[0] != "missingPath")
		{
			string $buffer[];
			tokenize ($pathList[0], "*", $buffer);
			for ($i = 1; $i < `size($buffer)`; $i ++)
			{
				$badNodeSize = size($badNode);
				$badNode[$badNodeSize] = $buffer[$i];
			}
		}
		if ($pathList[1] != "emptyCacheNode")
		{
			string $buffer[];
			tokenize ($pathList[1], "*", $buffer);
			for ($j = 1; $j < `size($buffer)`; $j ++)
			{
				$badNodeSize = size($badNode);
				$badNode[$badNodeSize] = $buffer[$j];
			}
		}
		for ($k = 2; $k < $pathListSize; $k ++)
		{
			string $bufferA[];
			tokenize($pathList[$k], "*", $bufferA);
			int $bufferASize = size($bufferA);
			for ($l = 1; $l < $bufferASize; $l ++)
			{
				$cacheNodeName = $bufferA[$l];
				$cacheDir = b2AddSlash(fromNativePath($bufferA[0]));
				$cacheName = `getAttr ($cacheNodeName + ".cacheName")`;
				$xmlFileSpec = $cacheName + "*.xml";
				$mcFileSpec = $cacheName + "*.mc";
				$badNodeSize = size($badNode);			
				string $xmlList[] = `getFileList -folder $cacheDir -filespec $xmlFileSpec`;
				string $mcList[] = `getFileList -folder $cacheDir -filespec $mcFileSpec`;
				if (size($xmlList) == 0)
				{
					$badNode[$badNodeSize] = $cacheNodeName;
				}
				if (size($mcList) == 0)
				{
					$badNode[$badNodeSize] = $cacheNodeName;
				}
			}
		}
			return $badNode;
	}
	//-/


	//- b2TestAllFileNodes씬 안의 모든 파일 노드의 리스트를 뽑아 각각의 경로를 검색한 후 빈 노드와 패스정보가 빠진 노드, 그리고 같은 경로를 참조하는 노드 그룹의 리스트를 반환.
	global proc string[] b2TestAllFileNodes()
	{
		print "b2TestAllFileNodes...____________________________________________starting up procedure\n";
		global string $selectFileNodesCommand;
		$selectFileNodesCommand = "ls -type file -type psdFileTex";
		string $fileNodes[] = `eval($selectFileNodesCommand)`;
		string $IBLs[];
		string $pathGroup[];
		string $fullPath;
		string $pathStrings[];
		string $normalNodes[];
		string $emptyNodes[];
		string $missingFileNodes[];
		
		if (`pluginInfo -q -loaded Mayatomr`)
		{
			// $IBLs = `ls -typ mentalrayIblShape`;
			$fileNodes = stringArrayCatenate($fileNodes, $IBLs);
		}
		int $fileNodesCount = `size($fileNodes)`;
		if ($fileNodesCount)
		{
			$pathGroup[0] = "emptyFileTexture";
			$pathGroup[1] = "missingPath";
		}

		for ($i = 0; $i < $fileNodesCount; $i ++)
		{
			int $pathGroupSize = size($pathGroup);
			string $type = `nodeType $fileNodes[$i]`;
			if (`nodeType $fileNodes[$i]` == "mentalrayIblShape")
			{
				string $iblType = `getAttr ($fileNodes[$i] + ".type")`;
				if ($iblType == 0)
				{
					$fullPath = toNativePath(substituteAll("\\\\", `getAttr($fileNodes[$i] + ".texture")`, "/"));
				}
				else
				{
					continue;
				}

			}
			else if (`nodeType $fileNodes[$i]` == "mentalrayTexture")
			{

				string $connectedNode[] = `connectionInfo -destinationFromSource ($fileNodes[$i] + ".message")`;
				string $bypassNode[] = { "misss_fast_skin_maya", "misss_fast_lmap_maya" };
				int $containResult = 0;			
				for ($node in $connectedNode)
				{
					string $nodeType = `nodeType $node`;
					$containResult += stringArrayContains ( $nodeType, $bypassNode );
				}
				if ($containResult > 0)
				{
					continue;
				}
				else
				{
					$fullPath = toNativePath(substituteAll("\\\\", `getAttr($fileNodes[$i] + ".fileTextureName")`, "/"));
				}
			}		
			else
			{
				if (`getAttr($fileNodes[$i] + ".useFrameExtension")` != 1)
				{
					$fullPath = toNativePath(substituteAll("\\\\",`getAttr($fileNodes[$i] + ".fileTextureName")`, "/"));
				}
				else
				{
					$fullPath = toNativePath(substituteAll("\\\\", `getAttr($fileNodes[$i] + ".fileTextureName")`, "/"));
					$fullPath = ("sq*" + $fullPath);
				}
			}
			string $pathOnly = dirname ($fullPath);
			string $existingPath;
			if (`size($pathOnly)`)
			{
				for ($j = 2; $j < $pathGroupSize; $j ++)
				{
					string $buffer[];
					tokenize($pathGroup[$j], "*", $buffer);
					if ($buffer[0] == "sq")
					{
						$existingPath = ($buffer[0] + "*" + $buffer[1]);
					}
					else
					{
						$existingPath = $buffer[0];
					}
					string $path1 = $pathOnly;
					string $path2 = $existingPath;
					if ($path1 == $path2)
					{
						string $tmp = $pathGroup[$j];
						$tmp += "*" + $fileNodes[$i];
						$pathGroup[$j] = $tmp;
						break;
					}
				}
				if ($j >= $pathGroupSize)
				{
					$pathGroup[$pathGroupSize] = ($pathOnly + "*" + $fileNodes[$i]);
				}
			}
			else if (`size($fullPath)`)
			{
				string $tmp = $pathGroup[1];
				$tmp += "*" + $fileNodes[$i];
				$pathGroup[1] = $tmp;
			}
			else
			{
				string $tmp = $pathGroup[0];
				$tmp += "*" + $fileNodes[$i];
				$pathGroup[0] = $tmp;
			}			
		}
		print "b2TestAllFileNodes...____________________________________________procedure is finished\n";	
		return $pathGroup;	
	}
	//-/


	//- b2CheckTextureExistence 씬에 존재하는 fileNode의 경로 정보를 체크하고 지정된 파일이 실제로 존재하는지 확인 후 문제가 있는 노드가 존재하면 그 리스트를 반환.
	global proc string[] b2CheckTextureExistence()
	{
		print "b2CheckTextureExistence...____________________________________________starting up procedure\n";
		string $pathList[] = `b2TestAllFileNodes`;
		int $pathListSize = size($pathList);
		string $fileNode;
		string $furDescNodes[] = `b2FurAttrMapList`;
		string $badNode[];
		int $badNodeSize;
		string $goodNode[];
		int $goodNodeSize;
		string $fileName;
		string $emptyNodes[];
		string $missingPathNodes[];
		if ($pathList[0] != "emptyFileTexture")
		{

			string $buffer[];
			tokenize ($pathList[0], "*", $buffer);
			for ($k = 1; $k < `size($buffer)`; $k ++)
			{
				$badNodeSize = size($badNode);
				$badNode[$badNodeSize] = $buffer[$k];
			}
		}
		if ($pathList[1] != "missingPath")
		{
			string $buffer[];
			tokenize ($pathList[1], "*", $buffer);
			for ($l = 1; $l < `size($buffer)`; $l ++)
			{
				$badNodeSize = size($badNode);
				$badNode[$badNodeSize] = $buffer[$l];
			}
		}
		for ($i = 2; $i < $pathListSize; $i ++)
		{
			string $buffer[];
			$badNodeSize = size($badNode);
			$goodNodeSize = size($goodNode);
			tokenize($pathList[$i], "*", $buffer);
			int $bufferSize = size($buffer);
			int $j;
			if ($buffer[0] == "sq")
			{
				$j = 2;
			}
			else
			{
				$j = 1;
			}
			for ($j; $j < $bufferSize; $j ++)
			{
				$fileNode = $buffer[$j];
				if (`nodeType $fileNode` == "mentalrayIblShape")
				{
					$fileName = `getAttr ($fileNode + ".texture")`;
				}
				else if (`nodeType $fileNode` == "mentalrayTexture")
				{
					$fileName = `getAttr($fileNode + ".fileTextureName")`;
				}
				else
				{
					$fileName = `getAttr($fileNode + ".fileTextureName")`;
				}
				if (`filetest -f $fileName` == 1)
				{
					$goodNode[$goodNodeSize] = $fileNode;
				}
				else
				{
					$badNode[$badNodeSize] = $fileNode;
				}
			}
		}
		for ($entry in $furDescNodes)
		{
			string $furNodeName[] = stringToStringArray ($entry, ".");
			print "$furNodeName[]\n";
			print $furNodeName;
			print "\n";
			string $attrMapPath = `getAttr $entry`;
			print ("$attrMapPath = " + $attrMapPath + "\n");
			if (!`filetest -f $attrMapPath`)
			{
				$badNode[size($badNode)] = $furNodeName[0];
			}
			else
			{
				$goodNode[size($goodNode)] = $furNodeName[0];
			}
		}
		return $badNode;
	}
	//-/


	//- b2GetAllFileTexturePath 모든 텍스쳐 경로 리스트를 반환
	global proc string[] b2GetAllFileTexturePaths()
	{
		print "b2GetAllFileTexturePaths...____________________________________________starting up procedure\n";
		string $pathList[] = `b2TestAllFileNodes`;
		string $returnList[];
		int $pathListSize = size($pathList);
		for ($i = 2; $i < $pathListSize; $i ++)
		{
			int $returnListSize = size($returnList);
			string $tokenizedString[];
			tokenize $pathList[$i] "*" $tokenizedString;
			$returnList[$returnListSize] = $tokenizedString[0];
		}
		return $returnList;
		print "b2GetAllFileTexturePaths...____________________________________________procedure is finished\n";
	}
	//-/	

	// b2CheckCamName
	// 기능		- 씬안에 규격에 맞게 네이밍 된 카메라가 있는지 확인 후 결과 반환
	// 
	// 출력		- 0 : 메인 카메라 없음
	//			- 1 : 메인 카메라 있음
	//			- 2 : 메인 카메라가 여러개 있음
	//			- 3 : 메인 카메라가 한 개 있으나 프레임 정보가 맞지 않음
	//-
	global proc int b2CheckCamName()
	{
		int $returnVal;
		string $allCamLst[] = `ls -type camera`;
		int $stFrame = `playbackOptions -q -min`;
		int $edFrame = `playbackOptions -q -max`;
		int $frameCheck;
		string $mainCam[];
		for( $eachCam in $allCamLst )
		{
			string $transformNode[] = `listRelatives -parent $eachCam`;
			string $matchMain = `match "cam_main_[0-9]+_[0-9]+" $transformNode[0]`;
			if( size($matchMain) )
			{
				$mainCam[size($mainCam)] = $eachCam;
				string $buffer[] = `stringToStringArray $transformNode[0] "_"`;
				print "$buffer =\n";
				print $buffer;
				print "\n";
				int $checkStFrame = $buffer[2];
				int $checkEdFrame = $buffer[3];
				if( $stFrame == $checkStFrame && $edFrame == $checkEdFrame )
				{
					$frameCheck = 1;
				}
				else
				{
					$frameCheck = 0;
				}
				print ("$frameCheck = " + $frameCheck + "\n" );
			}
		}
		if( size($mainCam) == 0 )
		{
			$returnVal = 0;
		}
		else if( size($mainCam) == 1 )
		{
			if( $frameCheck == 1)
			{
				$returnVal = 1;
			}
			else
			{
				$returnVal = 3;
			}
		}
		else if( size($mainCam) > 1 )
		{
			$returnVal = 2;
		}
		return $returnVal;
	}

	
	global proc string getMainCam()
	{
		string $allCamLst[] = `ls -type camera`;
		string $mainCam = "";
		for( $eachCam in $allCamLst )
		{
			string $transformNode[] = `listRelatives -parent $eachCam`;
			string $matchMain = `match "cam_main_[0-9]+_[0-9]+" $transformNode[0]`;
			if( size($matchMain) )
			{
				$mainCam = $transformNode[0];
				return $mainCam;
			}
		}
	}
	
	//-/
	
	
//-/


//- 기타등등

	//- b2GetDateTime 시스템 날짜와 시간 확인
	global proc string[] b2GetDateTime()
	{
		string $returnVal[];
		$returnVal[0] = `about -cd`;
		$returnVal[1] = `about -ct`;
		
		return $returnVal;
	}
	//-/


	global proc b2Print(string $title, string $statment)
	{
		print ("\n# " + $title);
		print $statment;
		print "\n";
	}


	global proc deleteOldMenuItem(string $optionMenuWidget)
	{
		string $oldMenuItems[] = `optionMenu -q -itemListLong $optionMenuWidget`;
		if (size($oldMenuItems))
		{
			for ($menuItem in $oldMenuItems)
			{
				deleteUI $menuItem;
			}
		}
	}	
//-/


//- UI보조도구

	//- b2CloseAllwin - 열려있는 모든 윈도우 닫기
	global proc int b2CloseAllWin()
	{
		string $allUIWin[] = `lsUI -windows`;
		string $defaultWin[] = { "MayaWindow", "b2PipeMainWin", "b2SubWin1", "nexFloatWindow", "takToolWin" };
		string $deleteWin[] = stringArrayRemove($defaultWin, $allUIWin);
		for ($window in $deleteWin)
		{
			deleteUI $window;
		}
		return 1;
	}
	//-/


	//- b2ResetViewportRender - 모든 뷰포트의 모드를 와이어프레임 렌더링으로 바꾸기
	global proc int b2ResetViewportRender()
	{
		string $allPanel[] = `getPanel -visiblePanels`;
		for ($panel	in $allPanel)
		{
			if (`getPanel -typeOf $panel` == "modelPanel")
			{
				modelEditor -edit -displayAppearance "wireframe" $panel;
			}
		}
		return 1;
	}
	//-/


	//- b2ToggleSelectAllFromList - textScrollList에서 전체 선택 / 해제
	global proc b2ToggleSelectAllFromList( string $uiName)
	{
		print "b1ToggleSelectAllFromList..._________________________________________________________starting up procedure\n";
		string $itemList[] = `textScrollList -q -allItems $uiName`;
		int $selectionCount = `textScrollList -q -numberOfSelectedItems $uiName`;
		if ($selectionCount)
		{
			textScrollList -edit -deselectAll $uiName;
		}
		else
		{
			for ($item in $itemList)
			{
				textScrollList -edit -selectItem $item $uiName;
			}
		}
		print "b1ToggleSelectAllFromList..._________________________________________________________end of procedure\n";	
	}
	//-/


	//- b2AddItemToList - textScrollList에 선택한 오브젝트의 최 상위 그룹 이름을 추가
	global proc b2AddItemToList( string $uiName )
	{
		string $addItem;
		string $selection[] = `ls -head 1 -sl`;
		string $refNodeName = eval ("referenceQuery -rfn " + $selection[0]);
		string $buffer[] = `stringToStringArray $selection[0] ":"`;
		if ($refNodeName != "")
		{		
			textScrollList -edit -append $buffer[0] $uiName;
		}
		else
		{
			confirmDialog -message "Referencing 된 어셋이 아닙니다";
		}
	}
	//-/



	//- b2RemoveItemFromList - textScrollList에서 선택한 아이템을 제거
	global proc b2RemoveItemFromList( string $uiName )
	{
		string $selection[] = `textScrollList -q -selectItem $uiName`;
		for ($item in $selection)
		{
			textScrollList -edit -removeItem $item $uiName;
		}
	}

	//-/

	
	//- b2MoveItemBetweenList
	global proc b2MoveItemBetweenList( string $fromList, string $toList )
	{
		string $sel[] = `textScrollList -q -selectItem $fromList`;
		string $toListItem[] = `textScrollList -q -allItems $toList`;
		string $appendItem[];
		for( $eachItem in $sel )
		{
			textScrollList -edit -removeItem $eachItem $fromList;
		}
		textScrollList -edit -removeAll $toList;		
		string $newToListItem[] = stringArrayCatenate( $sel, $toListItem );
		$newToListItem = `sort $newToListItem`;
		int $order = size( $newToListItem ) - 1;
		for( $toItem in $newToListItem )
		{
			textScrollList -edit -append $toItem $toList;
		}
	}
	
	//-/

		
	//- b2AddSnapshot2UI - 프리뷰 생성 UI에 이미지 추가
	global proc b2AddSnapshot2UI(string $file)
	{
		print "b2AddSnapshot2UI..._________________________________________________________________________________starting up procedure\n";
		int $version[] = `b2GetVersionFromFile $file ""`;
		string $imageName = ("snapshotImg" + $version[0]);
		string $plateName = ("snapshotImgPlate" + $version[0]);
		string $formName = ("snapshotImgForm" +$version[0]);
		string $checkName = ("snapshotImgCheck" +$version[0]);
		string $formLayout = `formLayout -parent imageSlot -width 320 -height 250 -numberOfDivisions 100 $formName`;
			string $imagePlate = `frameLayout -label ("snapshot_" + b2Pad($version[0], 3) + ".jpg") -parent $formName -width 320 -height 250 $plateName`;
				string $image = `image -i $file -parent $plateName $imageName`;
		setParent $formLayout;
			string $checkBox = `checkBox -label "" -parent $formName $checkName`;
	//setParent ..;
		formLayout -edit
			-attachForm $checkBox "top" 4
			-attachForm $checkBox "right" 6
		$formLayout;	
	}
	//-/	



	//- b2DelSnapshotFromUI - 프리뷰 생성 UI에서 이미지 제거
	global proc b2DelSnapshotFromUIold()
	{
		print "b2DelSnapshotFromUI..._________________________________________________________________________________starting up procedure\n";
		int $count = 1;
		int $i = 0;
		string $checkBoxName = ("snapshotImgCheck" + $count);
		string $checkedBoxList[];
		while (`checkBox -exists $checkBoxName`)
		{
			$count ++;
			$checkBoxName = ("snapshotImgCheck" + $count);
		}
		print ("b2DelSnapshotFromUI...total number of checkbox is " + $count + "\n");
		if ($count > 0)
		{
			for ($i = 1; $i < $count; $i ++)
			{
				$checkBoxName = ("snapshotImgCheck" + $i);
				int $stat = `checkBox -q -value $checkBoxName`;
				print ("b2DelSnapshotFromUI...value of checkBox " + $checkBoxName + " is " + $stat + "\n");
				if ($stat == 1)
				{
					$checkedBoxList[($i - 1)] = $i;
				}
			}
		}
		string $removeItem[] = {""};
		string $checkedBoxListDiff[] = `stringArrayRemove $removeItem $checkedBoxList`;
		int $checkedBoxCount = `size($checkedBoxListDiff)`;

		if ($checkedBoxCount > 0)
		{
			for ($j = 0; $j < $checkedBoxCount ; $j++)
			{
				string $delImgName = ("snapshotImg" + $checkedBoxListDiff[$j]);
				string $delPlateName = ("snapshotImgPlate" + $checkedBoxListDiff[$j]);
				string $delCheckBoxName = ("snapshotImgCheck" + $checkedBoxListDiff[$j]);
				string $delFormName = ("snapshotImgForm" + $checkedBoxListDiff[$j]);
				string $delFileName = ("c:/b2PipelineSnapshot/snapshot_" + b2Pad($checkedBoxListDiff[$j], 3) + ".jpg");
				print ("b2DelSnapshotFromUI...string in $delFileName is " + $delFileName + "\n");
				deleteUI $delImgName;
				deleteUI $delPlateName;
				deleteUI $delCheckBoxName;
				deleteUI $delFormName;
				sysFile -delete $delFileName;
			}
		}
	}
	//-/

	//- b2DelSnapshotFromUI - 프리뷰 생성 UI에서 이미지 제거
	global proc b2DelSnapshotFromUI()
	{
		string $chkBoxLst[] = `lsUI -type "checkBox"`;
		// string $shapshotChkBoxList[];
		for( $eachBox in $chkBoxLst )
		{
			if (`gmatch $eachBox "snapshotImgCheck?"`){
				if (`checkBox -q -v $eachBox`){

					print ($eachBox + "\n");
					string $delImgName = `substitute "Check" $eachBox ""`;
					string $delPlateName = `substitute "Check" $eachBox "Plate"`;
					string $delCheckBoxName = $eachBox;
					string $delFormName = `substitute "Check" $eachBox "Form"`;
					string $delFileName = `image -q -i $delImgName`;
					print ("b2DelSnapshotFromUI...string in $delFileName is " + $delFileName + "\n");
					deleteUI $delImgName;
					deleteUI $delPlateName;
					deleteUI $delCheckBoxName;
					deleteUI $delFormName;
					sysFile -delete $delFileName;

				}
			}
		}

	}


	//- b2SplitString - String을 쪼갬.
	global proc string[] b2SplitString(string $parm_srcStr, string $parm_splitStr)
	{
		python("tmpStr = '" + $parm_srcStr + "'");
		string $splitedStr[] = python("tmpStr.split('" + $parm_splitStr + "')");
		return $splitedStr;
	}
	//-/


	global proc fillTextFieldWithSelected(string $widgetType, string $widgetName)
	{
		/*
		Fill text field widget with selected object.

		Parameters:
			$widgetName: textField or textFieldGrp or textFieldButtonGrp widget name

		Returns:
			None
		*/

	    string $sel[] = `ls -sl`;

	    string $stringToExec = $widgetType + " -e -text " + $sel[0] + " " + $widgetName + ";";
	    eval $stringToExec;
	}
//-/
print "load b2PipelineUtil\n";
